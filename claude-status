#!/usr/bin/env python3
"""claude-status â€” show running Claude/Codex sessions across Ghostty tabs."""

import argparse
import concurrent.futures
import json
import os
import subprocess
import sys
import time


SESSION_COMMANDS = {"claude", "codex"}
DEFAULT_CPU_THRESHOLD = 5.0
CPU_THRESHOLD_ENV_VAR = "CLAUDE_STATUS_CPU_THRESHOLD"


def positive_float(value):
    """argparse type that accepts only values > 0."""
    parsed = float(value)
    if parsed <= 0:
        raise argparse.ArgumentTypeError("must be > 0")
    return parsed


def non_negative_float(value):
    """argparse type that accepts only values >= 0."""
    parsed = float(value)
    if parsed < 0:
        raise argparse.ArgumentTypeError("must be >= 0")
    return parsed


def parse_args():
    parser = argparse.ArgumentParser(
        description="Show running Claude/Codex sessions",
    )
    parser.add_argument(
        "--watch", action="store_true", help="re-print continuously"
    )
    parser.add_argument(
        "--interval", type=positive_float, default=2.0, metavar="SECS",
        help="refresh interval for --watch in seconds (default: 2)",
    )
    parser.add_argument(
        "--json", action="store_true", dest="json_output", help="output as JSON"
    )
    parser.add_argument(
        "--alert", action="store_true",
        help="notify when a session goes from active to idle (use with --watch)",
    )
    parser.add_argument(
        "--goto", metavar="PROJECT",
        help="focus the Ghostty tab running a session matching PROJECT",
    )
    parser.add_argument(
        "--cpu-threshold",
        type=non_negative_float,
        metavar="PERCENT",
        default=None,
        help=(
            "CPU percentage threshold for active sessions "
            "(default: 5.0, or CLAUDE_STATUS_CPU_THRESHOLD)"
        ),
    )
    return parser.parse_args()


def discover_claude_pids():
    """Find PIDs of running claude/codex processes via ps."""
    try:
        result = subprocess.run(
            ["ps", "-ax", "-o", "pid=,comm="],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            return []
        pids = []
        for line in result.stdout.strip().split("\n"):
            parts = line.strip().split(None, 1)
            if len(parts) == 2 and parts[1] in SESSION_COMMANDS:
                pids.append(int(parts[0]))
        return pids
    except FileNotFoundError:
        return []


def get_process_info(pids):
    """Get CPU%, state, and TTY for each PID in one ps call."""
    if not pids:
        return {}
    pid_str = ",".join(str(p) for p in pids)
    try:
        result = subprocess.run(
            ["ps", "-p", pid_str, "-o", "pid=,pcpu=,state=,tty="],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            return {}
    except FileNotFoundError:
        return {}

    info = {}
    for line in result.stdout.strip().split("\n"):
        if not line.strip():
            continue
        parts = line.split()
        if len(parts) < 3:
            continue
        try:
            pid = int(parts[0])
            cpu = float(parts[1])
        except ValueError:
            continue
        state = parts[2]
        tty = parts[3] if len(parts) >= 4 else "??"
        info[pid] = {"cpu": cpu, "state": state, "tty": tty}
    return info


def get_cwd(pid):
    """Resolve working directory for a process via lsof."""
    try:
        result = subprocess.run(
            ["lsof", "-a", "-p", str(pid), "-d", "cwd", "-Fn"],
            capture_output=True,
            text=True,
        )
        for line in result.stdout.strip().split("\n"):
            if line.startswith("n"):
                return line[1:]
    except FileNotFoundError:
        pass
    return None


def get_cwds(pids):
    """Resolve working directories for multiple PIDs in a single lsof call."""
    if not pids:
        return {}
    pid_str = ",".join(str(p) for p in pids)
    try:
        result = subprocess.run(
            ["lsof", "-a", "-p", pid_str, "-d", "cwd", "-Fn"],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0 and not result.stdout.strip():
            return {}
    except FileNotFoundError:
        return {}

    cwds = {}
    current_pid = None
    for line in result.stdout.strip().split("\n"):
        if not line:
            continue
        if line.startswith("p"):
            try:
                current_pid = int(line[1:])
            except ValueError:
                current_pid = None
        elif line.startswith("n") and current_pid is not None:
            cwds[current_pid] = line[1:]
    return cwds


def get_ghostty_surface_id(pid):
    """Try to extract GHOSTTY_SURFACE_ID from process environment."""
    try:
        result = subprocess.run(
            ["ps", "-p", str(pid), "-wwwE"],
            capture_output=True,
            text=True,
        )
        output = result.stdout
        for token in output.split():
            if token.startswith("GHOSTTY_SURFACE_ID="):
                return token.split("=", 1)[1]
    except FileNotFoundError:
        pass
    return None


def parse_etime(etime):
    """Parse ps etime format [[DD-]HH:]MM:SS to total seconds."""
    etime = etime.strip()
    if not etime:
        return None
    days = 0
    try:
        if "-" in etime:
            day_part, etime = etime.split("-", 1)
            days = int(day_part)
        parts = etime.split(":")
        if len(parts) == 3:
            hours, minutes, seconds = int(parts[0]), int(parts[1]), int(parts[2])
        elif len(parts) == 2:
            hours = 0
            minutes, seconds = int(parts[0]), int(parts[1])
        else:
            return None
    except ValueError:
        return None
    return days * 86400 + hours * 3600 + minutes * 60 + seconds


def format_duration(seconds):
    """Format seconds as a human-readable short duration string."""
    if seconds is None:
        return "-"
    if seconds < 60:
        return f"{seconds}s"
    if seconds < 3600:
        return f"{seconds // 60}m"
    if seconds < 86400:
        h = seconds // 3600
        m = (seconds % 3600) // 60
        return f"{h}h{m}m" if m else f"{h}h"
    d = seconds // 86400
    h = (seconds % 86400) // 3600
    return f"{d}d{h}h" if h else f"{d}d"


def get_uptime(pid):
    """Get process uptime via ps etime. Returns (seconds, formatted) or (None, '-')."""
    try:
        result = subprocess.run(
            ["ps", "-p", str(pid), "-o", "etime="],
            capture_output=True,
            text=True,
        )
        if result.returncode == 0 and result.stdout.strip():
            secs = parse_etime(result.stdout)
            if secs is not None:
                return (secs, format_duration(secs))
    except FileNotFoundError:
        pass
    return (None, "-")


def get_git_branch(cwd):
    """Get the current git branch for a directory. Returns branch name or None."""
    if cwd is None:
        return None
    try:
        result = subprocess.run(
            ["git", "-C", cwd, "rev-parse", "--abbrev-ref", "HEAD"],
            capture_output=True,
            text=True,
            timeout=2,
        )
        if result.returncode == 0:
            return result.stdout.strip() or None
    except (FileNotFoundError, subprocess.TimeoutExpired):
        pass
    return None


def classify_status(cpu, state, cpu_threshold=DEFAULT_CPU_THRESHOLD):
    """Classify session status based on CPU usage and process state."""
    if "T" in state:
        return "stopped"
    if cpu >= cpu_threshold:
        return "active"
    return "idle"


def resolve_cpu_threshold(args):
    """Resolve CPU threshold from CLI arg, env var, or default."""
    if args.cpu_threshold is not None:
        return args.cpu_threshold

    env_value = os.environ.get(CPU_THRESHOLD_ENV_VAR)
    if env_value is None:
        return DEFAULT_CPU_THRESHOLD

    try:
        threshold = float(env_value)
    except ValueError:
        sys.stderr.write(
            f"  Ignoring invalid {CPU_THRESHOLD_ENV_VAR} value '{env_value}'; "
            f"using default {DEFAULT_CPU_THRESHOLD}.\n"
        )
        return DEFAULT_CPU_THRESHOLD

    if threshold < 0:
        sys.stderr.write(
            f"  Ignoring invalid {CPU_THRESHOLD_ENV_VAR} value '{env_value}'; "
            f"using default {DEFAULT_CPU_THRESHOLD}.\n"
        )
        return DEFAULT_CPU_THRESHOLD

    return threshold


def send_bell():
    """Write terminal bell character to stdout."""
    sys.stdout.write("\a")
    sys.stdout.flush()


def send_notification(session):
    """Send a macOS desktop notification for a session."""
    project = session.get("project", "unknown")
    script = (
        'on run argv\n'
        'display notification "Waiting for input" with title "claude-status" subtitle (item 1 of argv)\n'
        "end run"
    )
    try:
        subprocess.run(
            [
                "osascript", "-e",
                script,
                project,
            ],
            capture_output=True,
            timeout=5,
        )
    except (FileNotFoundError, subprocess.TimeoutExpired):
        pass


def detect_transitions(previous_statuses, sessions):
    """Return set of PIDs that transitioned from active to idle."""
    transitioned = set()
    for s in sessions:
        pid = s["pid"]
        if pid in previous_statuses and previous_statuses[pid] == "active" and s["status"] == "idle":
            transitioned.add(pid)
    return transitioned


def alert_transitions(sessions, transitioned_pids):
    """Send bell + desktop notifications for sessions that finished working."""
    if not transitioned_pids:
        return
    send_bell()
    pid_to_session = {s["pid"]: s for s in sessions}
    for pid in transitioned_pids:
        if pid in pid_to_session:
            send_notification(pid_to_session[pid])


def disambiguate_projects(sessions):
    """If two sessions share a project basename, prepend parent dir."""
    name_counts = {}
    for s in sessions:
        name = s["project"]
        name_counts[name] = name_counts.get(name, 0) + 1

    for s in sessions:
        if name_counts[s["project"]] > 1 and s.get("cwd"):
            parent = os.path.basename(os.path.dirname(s["cwd"]))
            s["project"] = f"{parent}/{s['project']}"


def collect_sessions(cache=None, cpu_threshold=DEFAULT_CPU_THRESHOLD):
    """Collect all Claude/Codex session data.

    If cache (dict) is provided, CWD and surface_id are cached across calls
    and only fetched for newly discovered PIDs.  Stale entries are pruned.
    """
    pids = discover_claude_pids()
    if not pids:
        return []

    proc_info = get_process_info(pids)

    # Filter to TTY-attached processes before doing per-PID lookups
    valid_pids = [
        pid for pid in pids
        if pid in proc_info and proc_info[pid]["tty"] not in ("??", "")
    ]

    # Separate cached vs uncached PIDs
    if cache is not None:
        cached_pids = [p for p in valid_pids if p in cache]
        new_pids = [p for p in valid_pids if p not in cache]
        # Prune stale entries
        for stale in set(cache) - set(valid_pids):
            del cache[stale]
    else:
        cached_pids = []
        new_pids = valid_pids

    # Batch lsof for new PIDs only
    cwd_results = {}
    if cache is not None:
        for pid in cached_pids:
            cwd_results[pid] = cache[pid]["cwd"]
    if new_pids:
        cwd_results.update(get_cwds(new_pids))

    # Fetch surface_id + uptime in parallel (surface_id only for new PIDs)
    with concurrent.futures.ThreadPoolExecutor() as pool:
        sid_futures = {pid: pool.submit(get_ghostty_surface_id, pid) for pid in new_pids}
        uptime_futures = {pid: pool.submit(get_uptime, pid) for pid in valid_pids}

        # Dedup git branch lookups by unique CWD
        unique_cwds = set(cwd_results.values()) - {None}
        branch_futures = {cwd: pool.submit(get_git_branch, cwd) for cwd in unique_cwds}

    # Collect surface_id results, merge with cache
    sid_results = {}
    if cache is not None:
        for pid in cached_pids:
            sid_results[pid] = cache[pid]["surface_id"]
    for pid in new_pids:
        sid_results[pid] = sid_futures[pid].result()

    # Update cache with new entries
    if cache is not None:
        for pid in new_pids:
            cache[pid] = {"cwd": cwd_results.get(pid), "surface_id": sid_results.get(pid)}

    # Resolve branches (deduped)
    branch_results = {cwd: f.result() for cwd, f in branch_futures.items()}

    sessions = []
    for pid in valid_pids:
        info = proc_info[pid]
        cwd = cwd_results.get(pid)
        project = os.path.basename(cwd) if cwd else "unknown"
        surface_id = sid_results.get(pid)
        status = classify_status(info["cpu"], info["state"], cpu_threshold=cpu_threshold)
        uptime_seconds, uptime = uptime_futures[pid].result()
        branch = branch_results.get(cwd)

        sessions.append(
            {
                "pid": pid,
                "project": project,
                "cwd": cwd,
                "branch": branch,
                "status": status,
                "cpu": info["cpu"],
                "tty": info["tty"],
                "surface_id": surface_id,
                "uptime_seconds": uptime_seconds,
                "uptime": uptime,
            }
        )

    disambiguate_projects(sessions)

    # Sort: active first, then idle, then stopped; alphabetical within each group
    status_order = {"active": 0, "idle": 1, "stopped": 2}
    sessions.sort(key=lambda s: (status_order.get(s["status"], 9), s["project"]))

    return sessions


def supports_color():
    """Check if terminal supports color output."""
    if os.environ.get("NO_COLOR"):
        return False
    return hasattr(sys.stdout, "isatty") and sys.stdout.isatty()


STATUS_DISPLAY = {
    "active": {"icon": "\u25cf", "label": "active", "color": "\033[32m"},
    "idle": {"icon": "\u25d0", "label": "idle", "color": "\033[33m"},
    "stopped": {"icon": "\u25a0", "label": "stopped", "color": "\033[90m"},
}
RESET = "\033[0m"


YELLOW = "\033[33m"


def format_table(sessions, transitioned_pids=None):
    """Format sessions as an aligned table with optional ANSI colors."""
    if not sessions:
        return "  No active Claude/Codex sessions found.\n"

    use_color = supports_color()
    transitioned_pids = transitioned_pids or set()
    lines = []

    # Calculate column widths
    max_project = max(len(s["project"]) for s in sessions)
    max_branch = max(len(s.get("branch") or "-") for s in sessions)
    max_label = max(len(STATUS_DISPLAY[s["status"]]["label"]) for s in sessions)
    max_uptime = max(len(s.get("uptime", "-")) for s in sessions)

    for s in sessions:
        disp = STATUS_DISPLAY[s["status"]]
        icon = disp["icon"]
        label = disp["label"]
        branch = s.get("branch") or "-"
        uptime = s.get("uptime", "-")
        identifier = s["surface_id"][:8] if s["surface_id"] else s["tty"]

        if use_color:
            icon_str = f'{disp["color"]}{icon}{RESET}'
        else:
            icon_str = icon

        line = f"  {icon_str} {s['project']:<{max_project}}  {branch:<{max_branch}}  {label:<{max_label}}  {uptime:<{max_uptime}}  {identifier}"

        if s.get("pid") in transitioned_pids:
            if use_color:
                line += f"  {YELLOW}<- done{RESET}"
            else:
                line += "  <- done"

        lines.append(line)

    # Summary
    total = len(sessions)
    counts = {}
    for s in sessions:
        counts[s["status"]] = counts.get(s["status"], 0) + 1

    parts = []
    for status in ("active", "idle", "stopped"):
        if status in counts:
            parts.append(f"{counts[status]} {status}")

    lines.append("")
    noun = "session" if total == 1 else "sessions"
    lines.append(f"  {total} {noun} ({', '.join(parts)})")

    return "\n".join(lines) + "\n"


def format_json(sessions):
    """Format sessions as JSON."""
    return json.dumps(sessions, indent=2) + "\n"


def print_snapshot(json_output=False, cache=None, cpu_threshold=DEFAULT_CPU_THRESHOLD):
    """Collect and print one snapshot."""
    sessions = collect_sessions(cache=cache, cpu_threshold=cpu_threshold)
    if json_output:
        sys.stdout.write(format_json(sessions))
    else:
        sys.stdout.write(format_table(sessions))


def clear_screen():
    sys.stdout.write("\033[2J\033[H")
    sys.stdout.flush()


def focus_ghostty_surface(surface_id):
    """Focus a Ghostty surface via its URL scheme. Returns True on success."""
    try:
        result = subprocess.run(
            ["open", f"ghostty://present-surface/{surface_id}"],
            capture_output=True,
            text=True,
        )
        return result.returncode == 0
    except FileNotFoundError:
        return False


def handle_goto(project_query, cpu_threshold=DEFAULT_CPU_THRESHOLD):
    """Find a session by project name and focus its Ghostty surface."""
    sessions = collect_sessions(cpu_threshold=cpu_threshold)
    query = project_query.lower()
    matches = [s for s in sessions if query in s["project"].lower()]

    if not matches:
        sys.stderr.write(f"  No session matching '{project_query}'.\n")
        if sessions:
            sys.stderr.write("  Available sessions:\n")
            for s in sessions:
                sys.stderr.write(f"    - {s['project']}\n")
        return 1

    if len(matches) > 1:
        sys.stderr.write(f"  Multiple sessions match '{project_query}':\n")
        for s in matches:
            sys.stderr.write(f"    - {s['project']}\n")
        sys.stderr.write("  Be more specific.\n")
        return 1

    session = matches[0]
    if not session.get("surface_id"):
        sys.stderr.write(f"  Session '{session['project']}' has no Ghostty surface ID.\n")
        sys.stderr.write("  It may not be running inside Ghostty.\n")
        return 1

    if focus_ghostty_surface(session["surface_id"]):
        sys.stdout.write(f"  Focused: {session['project']}\n")
        return 0
    else:
        sys.stderr.write(f"  Failed to focus surface for '{session['project']}'.\n")
        return 1


def main():
    args = parse_args()
    cpu_threshold = resolve_cpu_threshold(args)

    if args.goto:
        sys.exit(handle_goto(args.goto, cpu_threshold=cpu_threshold))

    if args.watch:
        cache = {}
        previous_statuses = {}
        try:
            while True:
                if not args.json_output:
                    clear_screen()
                sessions = collect_sessions(cache=cache, cpu_threshold=cpu_threshold)

                transitioned_pids = set()
                if args.alert and previous_statuses:
                    transitioned_pids = detect_transitions(previous_statuses, sessions)
                    alert_transitions(sessions, transitioned_pids)

                previous_statuses = {s["pid"]: s["status"] for s in sessions}

                if args.json_output:
                    sys.stdout.write(format_json(sessions))
                else:
                    sys.stdout.write(format_table(sessions, transitioned_pids=transitioned_pids))
                time.sleep(args.interval)
        except KeyboardInterrupt:
            pass
    else:
        print_snapshot(json_output=args.json_output, cpu_threshold=cpu_threshold)


if __name__ == "__main__":
    main()
