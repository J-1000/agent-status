#!/usr/bin/env python3
"""claude-status â€” show running Claude Code sessions across Ghostty tabs."""

import argparse
import concurrent.futures
import json
import os
import subprocess
import sys
import time


def parse_args():
    parser = argparse.ArgumentParser(
        description="Show running Claude Code sessions",
    )
    parser.add_argument(
        "--watch", action="store_true", help="re-print continuously"
    )
    parser.add_argument(
        "--interval", type=float, default=2.0, metavar="SECS",
        help="refresh interval for --watch in seconds (default: 2)",
    )
    parser.add_argument(
        "--json", action="store_true", dest="json_output", help="output as JSON"
    )
    return parser.parse_args()


def discover_claude_pids():
    """Find PIDs of running `claude` processes via ps (more reliable than pgrep)."""
    try:
        result = subprocess.run(
            ["ps", "-ax", "-o", "pid=,comm="],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            return []
        pids = []
        for line in result.stdout.strip().split("\n"):
            parts = line.strip().split(None, 1)
            if len(parts) == 2 and parts[1] == "claude":
                pids.append(int(parts[0]))
        return pids
    except FileNotFoundError:
        return []


def get_process_info(pids):
    """Get CPU%, state, and TTY for each PID in one ps call."""
    if not pids:
        return {}
    pid_str = ",".join(str(p) for p in pids)
    try:
        result = subprocess.run(
            ["ps", "-p", pid_str, "-o", "pid=,pcpu=,state=,tty="],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            return {}
    except FileNotFoundError:
        return {}

    info = {}
    for line in result.stdout.strip().split("\n"):
        if not line.strip():
            continue
        parts = line.split()
        if len(parts) < 3:
            continue
        try:
            pid = int(parts[0])
            cpu = float(parts[1])
        except ValueError:
            continue
        state = parts[2]
        tty = parts[3] if len(parts) >= 4 else "??"
        info[pid] = {"cpu": cpu, "state": state, "tty": tty}
    return info


def get_cwd(pid):
    """Resolve working directory for a process via lsof."""
    try:
        result = subprocess.run(
            ["lsof", "-a", "-p", str(pid), "-d", "cwd", "-Fn"],
            capture_output=True,
            text=True,
        )
        for line in result.stdout.strip().split("\n"):
            if line.startswith("n"):
                return line[1:]
    except FileNotFoundError:
        pass
    return None


def get_ghostty_surface_id(pid):
    """Try to extract GHOSTTY_SURFACE_ID from process environment."""
    try:
        result = subprocess.run(
            ["ps", "-p", str(pid), "-wwwE"],
            capture_output=True,
            text=True,
        )
        output = result.stdout
        for token in output.split():
            if token.startswith("GHOSTTY_SURFACE_ID="):
                return token.split("=", 1)[1]
    except FileNotFoundError:
        pass
    return None


CPU_THRESHOLD = 5.0  # percent above which a session is "active"


def classify_status(cpu, state):
    """Classify session status based on CPU usage and process state."""
    if "T" in state:
        return "stopped"
    if cpu >= CPU_THRESHOLD:
        return "active"
    return "idle"


def disambiguate_projects(sessions):
    """If two sessions share a project basename, prepend parent dir."""
    name_counts = {}
    for s in sessions:
        name = s["project"]
        name_counts[name] = name_counts.get(name, 0) + 1

    for s in sessions:
        if name_counts[s["project"]] > 1 and s.get("cwd"):
            parent = os.path.basename(os.path.dirname(s["cwd"]))
            s["project"] = f"{parent}/{s['project']}"


def collect_sessions():
    """Collect all Claude Code session data."""
    pids = discover_claude_pids()
    if not pids:
        return []

    proc_info = get_process_info(pids)

    # Filter to TTY-attached processes before doing per-PID lookups
    valid_pids = [
        pid for pid in pids
        if pid in proc_info and proc_info[pid]["tty"] not in ("??", "")
    ]

    # Fetch cwd and surface_id in parallel to avoid N+1 subprocess overhead
    with concurrent.futures.ThreadPoolExecutor() as pool:
        cwd_futures = {pid: pool.submit(get_cwd, pid) for pid in valid_pids}
        sid_futures = {pid: pool.submit(get_ghostty_surface_id, pid) for pid in valid_pids}

    sessions = []
    for pid in valid_pids:
        info = proc_info[pid]
        cwd = cwd_futures[pid].result()
        project = os.path.basename(cwd) if cwd else "unknown"
        surface_id = sid_futures[pid].result()
        status = classify_status(info["cpu"], info["state"])

        sessions.append(
            {
                "pid": pid,
                "project": project,
                "cwd": cwd,
                "status": status,
                "cpu": info["cpu"],
                "tty": info["tty"],
                "surface_id": surface_id,
            }
        )

    disambiguate_projects(sessions)

    # Sort: active first, then idle, then stopped; alphabetical within each group
    status_order = {"active": 0, "idle": 1, "stopped": 2}
    sessions.sort(key=lambda s: (status_order.get(s["status"], 9), s["project"]))

    return sessions


def supports_color():
    """Check if terminal supports color output."""
    if os.environ.get("NO_COLOR"):
        return False
    return hasattr(sys.stdout, "isatty") and sys.stdout.isatty()


STATUS_DISPLAY = {
    "active": {"icon": "\u25cf", "label": "active", "color": "\033[32m"},
    "idle": {"icon": "\u25d0", "label": "idle", "color": "\033[33m"},
    "stopped": {"icon": "\u25a0", "label": "stopped", "color": "\033[90m"},
}
RESET = "\033[0m"


def format_table(sessions):
    """Format sessions as an aligned table with optional ANSI colors."""
    if not sessions:
        return "  No active Claude Code sessions found.\n"

    use_color = supports_color()
    lines = []

    # Calculate column widths
    max_project = max(len(s["project"]) for s in sessions)
    max_label = max(len(STATUS_DISPLAY[s["status"]]["label"]) for s in sessions)

    for s in sessions:
        disp = STATUS_DISPLAY[s["status"]]
        icon = disp["icon"]
        label = disp["label"]
        identifier = s["surface_id"][:8] if s["surface_id"] else s["tty"]

        if use_color:
            icon_str = f'{disp["color"]}{icon}{RESET}'
        else:
            icon_str = icon

        line = f"  {icon_str} {s['project']:<{max_project}}  {label:<{max_label}}  {identifier}"
        lines.append(line)

    # Summary
    total = len(sessions)
    counts = {}
    for s in sessions:
        counts[s["status"]] = counts.get(s["status"], 0) + 1

    parts = []
    for status in ("active", "idle", "stopped"):
        if status in counts:
            parts.append(f"{counts[status]} {status}")

    lines.append("")
    noun = "session" if total == 1 else "sessions"
    lines.append(f"  {total} {noun} ({', '.join(parts)})")

    return "\n".join(lines) + "\n"


def format_json(sessions):
    """Format sessions as JSON."""
    return json.dumps(sessions, indent=2) + "\n"


def print_snapshot(json_output=False):
    """Collect and print one snapshot."""
    sessions = collect_sessions()
    if json_output:
        sys.stdout.write(format_json(sessions))
    else:
        sys.stdout.write(format_table(sessions))


def clear_screen():
    sys.stdout.write("\033[2J\033[H")
    sys.stdout.flush()


def main():
    args = parse_args()

    if args.watch:
        try:
            while True:
                clear_screen()
                print_snapshot(json_output=args.json_output)
                time.sleep(args.interval)
        except KeyboardInterrupt:
            pass
    else:
        print_snapshot(json_output=args.json_output)


if __name__ == "__main__":
    main()
