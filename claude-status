#!/usr/bin/env python3
"""claude-status â€” show running Claude Code sessions across Ghostty tabs."""

import argparse
import os
import subprocess
import sys


def parse_args():
    parser = argparse.ArgumentParser(
        description="Show running Claude Code sessions",
    )
    parser.add_argument(
        "--watch", action="store_true", help="re-print every 2 seconds"
    )
    parser.add_argument(
        "--json", action="store_true", dest="json_output", help="output as JSON"
    )
    return parser.parse_args()


def discover_claude_pids():
    """Find PIDs of running `claude` processes via ps (more reliable than pgrep)."""
    try:
        result = subprocess.run(
            ["ps", "-ax", "-o", "pid=,comm="],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            return []
        pids = []
        for line in result.stdout.strip().split("\n"):
            parts = line.strip().split(None, 1)
            if len(parts) == 2 and parts[1] == "claude":
                pids.append(int(parts[0]))
        return pids
    except FileNotFoundError:
        return []


def get_process_info(pids):
    """Get CPU%, state, and TTY for each PID in one ps call."""
    if not pids:
        return {}
    pid_str = ",".join(str(p) for p in pids)
    try:
        result = subprocess.run(
            ["ps", "-p", pid_str, "-o", "pid=,pcpu=,state=,tty="],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            return {}
    except FileNotFoundError:
        return {}

    info = {}
    for line in result.stdout.strip().split("\n"):
        if not line.strip():
            continue
        parts = line.split()
        if len(parts) >= 4:
            pid = int(parts[0])
            cpu = float(parts[1])
            state = parts[2]
            tty = parts[3]
            info[pid] = {"cpu": cpu, "state": state, "tty": tty}
        elif len(parts) == 3:
            # tty might be missing (shows as ??)
            pid = int(parts[0])
            cpu = float(parts[1])
            state = parts[2]
            info[pid] = {"cpu": cpu, "state": state, "tty": "??"}
    return info


def get_cwd(pid):
    """Resolve working directory for a process via lsof."""
    try:
        result = subprocess.run(
            ["lsof", "-a", "-p", str(pid), "-d", "cwd", "-Fn"],
            capture_output=True,
            text=True,
        )
        for line in result.stdout.strip().split("\n"):
            if line.startswith("n"):
                return line[1:]
    except FileNotFoundError:
        pass
    return None


def get_ghostty_surface_id(pid):
    """Try to extract GHOSTTY_SURFACE_ID from process environment."""
    try:
        result = subprocess.run(
            ["ps", "-p", str(pid), "-wwwE"],
            capture_output=True,
            text=True,
        )
        output = result.stdout
        for token in output.split():
            if token.startswith("GHOSTTY_SURFACE_ID="):
                return token.split("=", 1)[1]
    except FileNotFoundError:
        pass
    return None


CPU_THRESHOLD = 5.0  # percent above which a session is "active"


def classify_status(cpu, state):
    """Classify session status based on CPU usage and process state."""
    if "T" in state:
        return "stopped"
    if cpu >= CPU_THRESHOLD:
        return "active"
    return "idle"


def disambiguate_projects(sessions):
    """If two sessions share a project basename, prepend parent dir."""
    name_counts = {}
    for s in sessions:
        name = s["project"]
        name_counts[name] = name_counts.get(name, 0) + 1

    for s in sessions:
        if name_counts[s["project"]] > 1 and s.get("cwd"):
            parent = os.path.basename(os.path.dirname(s["cwd"]))
            s["project"] = f"{parent}/{s['project']}"


def collect_sessions():
    """Collect all Claude Code session data."""
    pids = discover_claude_pids()
    if not pids:
        return []

    proc_info = get_process_info(pids)
    sessions = []

    for pid in pids:
        info = proc_info.get(pid)
        if not info:
            continue

        # Skip processes without a TTY (headless/background)
        if info["tty"] == "??" or info["tty"] == "":
            continue

        cwd = get_cwd(pid)
        project = os.path.basename(cwd) if cwd else "unknown"
        surface_id = get_ghostty_surface_id(pid)
        status = classify_status(info["cpu"], info["state"])

        sessions.append(
            {
                "pid": pid,
                "project": project,
                "cwd": cwd,
                "status": status,
                "cpu": info["cpu"],
                "tty": info["tty"],
                "surface_id": surface_id,
            }
        )

    disambiguate_projects(sessions)
    return sessions


def main():
    args = parse_args()
    sessions = collect_sessions()
    if not sessions:
        print("  No active Claude Code sessions found.")
        return
    for s in sessions:
        print(f"  {s['status']:<8} {s['project']:<16} {s['tty']}")


if __name__ == "__main__":
    main()
