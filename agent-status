#!/usr/bin/env python3
"""agent-status â€” show running Claude/Codex sessions across Ghostty tabs."""

import argparse
import concurrent.futures
from datetime import datetime, timezone
import json
import os
import re
import subprocess
import sys
import time


SESSION_COMMANDS = {"claude", "codex"}
DEFAULT_CPU_THRESHOLD = 5.0
CPU_THRESHOLD_ENV_VAR = "AGENT_STATUS_CPU_THRESHOLD"
LEGACY_CPU_THRESHOLD_ENV_VAR = "CLAUDE_STATUS_CPU_THRESHOLD"
JSON_V2_SCHEMA_VERSION = 1
GHOSTTY_SURFACE_RE = re.compile(r"(?:^|\s)GHOSTTY_SURFACE_ID=([^\s]+)")
ALERT_STATUSES = {"active", "idle", "stopped"}
DEFAULT_ALERT_ON = [("active", "idle")]
REGISTRY_ENV_VAR = "AGENT_STATUS_REGISTRY"
DEFAULT_REGISTRY_PATH = os.path.expanduser("~/.agent-status/registrations.jsonl")


def positive_float(value):
    """argparse type that accepts only values > 0."""
    parsed = float(value)
    if parsed <= 0:
        raise argparse.ArgumentTypeError("must be > 0")
    return parsed


def non_negative_float(value):
    """argparse type that accepts only values >= 0."""
    parsed = float(value)
    if parsed < 0:
        raise argparse.ArgumentTypeError("must be >= 0")
    return parsed


def positive_int(value):
    """argparse type that accepts only integer values > 0."""
    parsed = int(value)
    if parsed <= 0:
        raise argparse.ArgumentTypeError("must be > 0")
    return parsed


def parse_alert_on(raw_values):
    """Parse alert transition specifiers like 'active->idle,active->stopped'."""
    if not raw_values:
        return list(DEFAULT_ALERT_ON)

    transitions = []
    seen = set()
    for raw in raw_values:
        if raw is None:
            continue
        for chunk in raw.split(","):
            chunk = chunk.strip()
            if not chunk:
                continue
            if "->" not in chunk:
                raise ValueError(
                    f"invalid transition '{chunk}'; expected format 'from->to'"
                )
            parts = chunk.split("->")
            if len(parts) != 2:
                raise ValueError(
                    f"invalid transition '{chunk}'; expected format 'from->to'"
                )
            from_status = parts[0].strip()
            to_status = parts[1].strip()
            if from_status not in ALERT_STATUSES or to_status not in ALERT_STATUSES:
                raise ValueError(
                    f"invalid transition '{chunk}'; valid statuses: "
                    f"{', '.join(sorted(ALERT_STATUSES))}"
                )
            key = (from_status, to_status)
            if key not in seen:
                transitions.append(key)
                seen.add(key)

    if not transitions:
        return list(DEFAULT_ALERT_ON)

    return transitions


def parse_args():
    parser = argparse.ArgumentParser(
        description="Show running Claude/Codex sessions",
    )
    parser.add_argument(
        "--watch", action="store_true", help="re-print continuously"
    )
    parser.add_argument(
        "--interval", type=positive_float, default=2.0, metavar="SECS",
        help="refresh interval for --watch in seconds (default: 2)",
    )
    parser.add_argument(
        "--interval-active", type=positive_float, default=None, metavar="SECS",
        help="watch interval while any session is active (defaults to --interval)",
    )
    parser.add_argument(
        "--interval-idle", type=positive_float, default=None, metavar="SECS",
        help="watch interval when no sessions are active (defaults to --interval)",
    )
    parser.add_argument(
        "--json", action="store_true", dest="json_output", help="output as JSON"
    )
    parser.add_argument(
        "--json-v2", action="store_true",
        help="output JSON envelope with metadata",
    )
    parser.add_argument(
        "--alert", action="store_true",
        help="notify when a session goes from active to idle (use with --watch)",
    )
    parser.add_argument(
        "--alert-on",
        action="append",
        metavar="TRANSITIONS",
        help=(
            "comma-separated transitions to alert on, e.g. 'active->idle,active->stopped' "
            "(default: active->idle)"
        ),
    )
    parser.add_argument(
        "--alert-cooldown",
        type=non_negative_float,
        default=0.0,
        metavar="SECS",
        help="minimum seconds between alerts for the same session/transition (default: 0)",
    )
    parser.add_argument(
        "--no-task",
        action="store_true",
        help="omit registered task column from table output",
    )
    parser.add_argument(
        "--task-width",
        type=positive_int,
        default=24,
        metavar="CHARS",
        help="maximum width for task column in table output (default: 24)",
    )
    parser.add_argument(
        "--goto", metavar="PROJECT",
        help="focus the Ghostty tab running a session matching PROJECT",
    )
    parser.add_argument(
        "--cpu-threshold",
        type=non_negative_float,
        metavar="PERCENT",
        default=None,
        help=(
            "CPU percentage threshold for active sessions "
            "(default: 5.0, or AGENT_STATUS_CPU_THRESHOLD)"
        ),
    )
    args = parser.parse_args()
    try:
        args.alert_on = parse_alert_on(args.alert_on)
    except ValueError as exc:
        parser.error(str(exc))
    return args


def discover_claude_pids():
    """Find PIDs of running claude/codex processes via ps."""
    try:
        result = subprocess.run(
            ["ps", "-ax", "-o", "pid=,comm="],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            return []
        pids = []
        for line in result.stdout.strip().split("\n"):
            parts = line.strip().split(None, 1)
            if len(parts) == 2 and parts[1] in SESSION_COMMANDS:
                pids.append(int(parts[0]))
        return pids
    except FileNotFoundError:
        return []


def get_process_info(pids):
    """Get CPU%, state, and TTY for each PID in one ps call."""
    if not pids:
        return {}
    pid_str = ",".join(str(p) for p in pids)
    try:
        result = subprocess.run(
            ["ps", "-p", pid_str, "-o", "pid=,pcpu=,state=,tty="],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            return {}
    except FileNotFoundError:
        return {}

    info = {}
    for line in result.stdout.strip().split("\n"):
        if not line.strip():
            continue
        parts = line.split()
        if len(parts) < 3:
            continue
        try:
            pid = int(parts[0])
            cpu = float(parts[1])
        except ValueError:
            continue
        state = parts[2]
        tty = parts[3] if len(parts) >= 4 else "??"
        info[pid] = {"cpu": cpu, "state": state, "tty": tty}
    return info


def get_parent_map(pids):
    """Get parent PID for each PID in one ps call."""
    if not pids:
        return {}
    pid_str = ",".join(str(p) for p in pids)
    try:
        result = subprocess.run(
            ["ps", "-p", pid_str, "-o", "pid=,ppid="],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            return {}
    except FileNotFoundError:
        return {}

    parent_map = {}
    for line in result.stdout.strip().split("\n"):
        parts = line.split()
        if len(parts) != 2:
            continue
        try:
            pid = int(parts[0])
            ppid = int(parts[1])
        except ValueError:
            continue
        parent_map[pid] = ppid
    return parent_map


def dedupe_nested_pids(pids, parent_map):
    """Drop PID if any ancestor is also in pids."""
    pid_set = set(pids)
    deduped = []
    for pid in pids:
        seen = set()
        parent = parent_map.get(pid)
        nested = False
        while parent and parent > 0 and parent not in seen:
            if parent in pid_set:
                nested = True
                break
            seen.add(parent)
            parent = parent_map.get(parent)
        if not nested:
            deduped.append(pid)
    return deduped


def get_cwd(pid):
    """Resolve working directory for a process via lsof."""
    try:
        result = subprocess.run(
            ["lsof", "-a", "-p", str(pid), "-d", "cwd", "-Fn"],
            capture_output=True,
            text=True,
        )
        for line in result.stdout.strip().split("\n"):
            if line.startswith("n"):
                return line[1:]
    except FileNotFoundError:
        pass
    return None


def get_cwds(pids):
    """Resolve working directories for multiple PIDs in a single lsof call."""
    if not pids:
        return {}
    pid_str = ",".join(str(p) for p in pids)
    try:
        result = subprocess.run(
            ["lsof", "-a", "-p", pid_str, "-d", "cwd", "-Fn"],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0 and not result.stdout.strip():
            return {}
    except FileNotFoundError:
        return {}

    cwds = {}
    current_pid = None
    for line in result.stdout.strip().split("\n"):
        if not line:
            continue
        if line.startswith("p"):
            try:
                current_pid = int(line[1:])
            except ValueError:
                current_pid = None
        elif line.startswith("n") and current_pid is not None:
            cwds[current_pid] = line[1:]
    return cwds


def get_ghostty_surface_id(pid):
    """Try to extract GHOSTTY_SURFACE_ID from process environment."""
    commands = [
        ["ps", "-p", str(pid), "-wwwE"],
        ["ps", "-p", str(pid), "-eww", "-o", "command="],
    ]
    try:
        for command in commands:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
            )
            if result.returncode != 0:
                continue
            match = GHOSTTY_SURFACE_RE.search(result.stdout)
            if match:
                return match.group(1)
    except FileNotFoundError:
        pass
    return None


def parse_etime(etime):
    """Parse ps etime format [[DD-]HH:]MM:SS to total seconds."""
    etime = etime.strip()
    if not etime:
        return None
    days = 0
    try:
        if "-" in etime:
            day_part, etime = etime.split("-", 1)
            days = int(day_part)
        parts = etime.split(":")
        if len(parts) == 3:
            hours, minutes, seconds = int(parts[0]), int(parts[1]), int(parts[2])
        elif len(parts) == 2:
            hours = 0
            minutes, seconds = int(parts[0]), int(parts[1])
        else:
            return None
    except ValueError:
        return None
    return days * 86400 + hours * 3600 + minutes * 60 + seconds


def format_duration(seconds):
    """Format seconds as a human-readable short duration string."""
    if seconds is None:
        return "-"
    if seconds < 60:
        return f"{seconds}s"
    if seconds < 3600:
        return f"{seconds // 60}m"
    if seconds < 86400:
        h = seconds // 3600
        m = (seconds % 3600) // 60
        return f"{h}h{m}m" if m else f"{h}h"
    d = seconds // 86400
    h = (seconds % 86400) // 3600
    return f"{d}d{h}h" if h else f"{d}d"


def get_uptime(pid):
    """Get process uptime via ps etime. Returns (seconds, formatted) or (None, '-')."""
    try:
        result = subprocess.run(
            ["ps", "-p", str(pid), "-o", "etime="],
            capture_output=True,
            text=True,
        )
        if result.returncode == 0 and result.stdout.strip():
            secs = parse_etime(result.stdout)
            if secs is not None:
                return (secs, format_duration(secs))
    except FileNotFoundError:
        pass
    return (None, "-")


def get_git_branch(cwd):
    """Get the current git branch for a directory. Returns branch name or None."""
    if cwd is None:
        return None
    try:
        result = subprocess.run(
            ["git", "-C", cwd, "rev-parse", "--abbrev-ref", "HEAD"],
            capture_output=True,
            text=True,
            timeout=2,
        )
        if result.returncode == 0:
            return result.stdout.strip() or None
    except (FileNotFoundError, subprocess.TimeoutExpired):
        pass
    return None


def classify_status(cpu, state, cpu_threshold=DEFAULT_CPU_THRESHOLD):
    """Classify session status based on CPU usage and process state."""
    if "T" in state:
        return "stopped"
    if cpu >= cpu_threshold:
        return "active"
    return "idle"


def resolve_cpu_threshold(args):
    """Resolve CPU threshold from CLI arg, env var, or default."""
    if args.cpu_threshold is not None:
        return args.cpu_threshold

    env_value = os.environ.get(CPU_THRESHOLD_ENV_VAR)
    env_name = CPU_THRESHOLD_ENV_VAR
    if env_value is None:
        env_value = os.environ.get(LEGACY_CPU_THRESHOLD_ENV_VAR)
        env_name = LEGACY_CPU_THRESHOLD_ENV_VAR
    if env_value is None:
        return DEFAULT_CPU_THRESHOLD

    try:
        threshold = float(env_value)
    except ValueError:
        sys.stderr.write(
            f"  Ignoring invalid {env_name} value '{env_value}'; "
            f"using default {DEFAULT_CPU_THRESHOLD}.\n"
        )
        return DEFAULT_CPU_THRESHOLD

    if threshold < 0:
        sys.stderr.write(
            f"  Ignoring invalid {env_name} value '{env_value}'; "
            f"using default {DEFAULT_CPU_THRESHOLD}.\n"
        )
        return DEFAULT_CPU_THRESHOLD

    return threshold


def send_bell():
    """Write terminal bell character to stdout."""
    sys.stdout.write("\a")
    sys.stdout.flush()


def transition_message(from_status, to_status):
    """Return a human-readable message for a transition."""
    if from_status == "active" and to_status == "idle":
        return "Waiting for input"
    if to_status == "stopped":
        return "Session stopped"
    if to_status == "active":
        return "Session active"
    return f"Status changed: {from_status} -> {to_status}"


def send_notification(session, transition):
    """Send a macOS desktop notification for a session transition."""
    project = session.get("project", "unknown")
    message = transition_message(transition["from"], transition["to"])
    script = (
        'on run argv\n'
        'display notification (item 2 of argv) with title "agent-status" subtitle (item 1 of argv)\n'
        "end run"
    )
    try:
        subprocess.run(
            [
                "osascript", "-e",
                script,
                project,
                message,
            ],
            capture_output=True,
            timeout=5,
        )
    except (FileNotFoundError, subprocess.TimeoutExpired):
        pass


def detect_transitions(previous_statuses, sessions, alert_on):
    """Return list of transitions that match alert_on."""
    transitions = []
    alert_set = set(alert_on)
    for s in sessions:
        pid = s["pid"]
        previous = previous_statuses.get(pid)
        if not previous:
            continue
        current = s["status"]
        if (previous, current) in alert_set:
            transitions.append({"pid": pid, "from": previous, "to": current})
    return transitions


def alert_transitions(sessions, transitions, cooldown_seconds=0.0, last_alerts=None):
    """Send bell + desktop notifications for alertable transitions."""
    if not transitions:
        return []
    now = time.monotonic()
    alerted = []
    pid_to_session = {s["pid"]: s for s in sessions}

    for transition in transitions:
        key = (transition["pid"], transition["from"], transition["to"])
        if last_alerts is not None and cooldown_seconds > 0:
            last = last_alerts.get(key)
            if last is not None and (now - last) < cooldown_seconds:
                continue
        alerted.append(transition)
        if last_alerts is not None:
            last_alerts[key] = now

    if not alerted:
        return []

    send_bell()
    for transition in alerted:
        session = pid_to_session.get(transition["pid"])
        if session:
            send_notification(session, transition)
    return alerted


def disambiguate_projects(sessions):
    """If two sessions share a project basename, prepend parent dir."""
    name_counts = {}
    for s in sessions:
        name = s["project"]
        name_counts[name] = name_counts.get(name, 0) + 1

    for s in sessions:
        if name_counts[s["project"]] > 1 and s.get("cwd"):
            parent = os.path.basename(os.path.dirname(s["cwd"]))
            s["project"] = f"{parent}/{s['project']}"


def resolve_registry_path():
    """Return registry path for session registrations."""
    return os.environ.get(REGISTRY_ENV_VAR, DEFAULT_REGISTRY_PATH)


def load_registrations(pids, registry_path=None):
    """Load registration metadata for the given PIDs."""
    if not pids:
        return {}
    path = registry_path or resolve_registry_path()
    try:
        with open(path, "r", encoding="utf-8") as handle:
            entries = {}
            for line in handle:
                line = line.strip()
                if not line:
                    continue
                try:
                    record = json.loads(line)
                except json.JSONDecodeError:
                    continue
                pid = record.get("pid")
                if pid in pids:
                    entries[pid] = record
            return entries
    except FileNotFoundError:
        return {}


def collect_sessions(cache=None, cpu_threshold=DEFAULT_CPU_THRESHOLD):
    """Collect all Claude/Codex session data.

    If cache (dict) is provided, CWD and surface_id are cached across calls
    and only fetched for newly discovered PIDs.  Stale entries are pruned.
    """
    pids = discover_claude_pids()
    if not pids:
        return []

    proc_info = get_process_info(pids)

    # Filter to TTY-attached processes before doing per-PID lookups
    valid_pids = [
        pid for pid in pids
        if pid in proc_info and proc_info[pid]["tty"] not in ("??", "")
    ]
    parent_map = get_parent_map(valid_pids)
    valid_pids = dedupe_nested_pids(valid_pids, parent_map)
    registrations = load_registrations(valid_pids)

    # Separate cached vs uncached PIDs
    if cache is not None:
        cached_pids = [p for p in valid_pids if p in cache]
        new_pids = [p for p in valid_pids if p not in cache]
        # Prune stale entries
        for stale in set(cache) - set(valid_pids):
            del cache[stale]
    else:
        cached_pids = []
        new_pids = valid_pids

    # Batch lsof for new PIDs only
    cwd_results = {}
    if cache is not None:
        for pid in cached_pids:
            cwd_results[pid] = cache[pid]["cwd"]
    if new_pids:
        cwd_results.update(get_cwds(new_pids))

    # Fetch surface_id + uptime in parallel (surface_id only for new PIDs)
    with concurrent.futures.ThreadPoolExecutor() as pool:
        sid_futures = {pid: pool.submit(get_ghostty_surface_id, pid) for pid in new_pids}
        uptime_futures = {pid: pool.submit(get_uptime, pid) for pid in valid_pids}

        # Dedup git branch lookups by unique CWD
        unique_cwds = set(cwd_results.values()) - {None}
        branch_futures = {cwd: pool.submit(get_git_branch, cwd) for cwd in unique_cwds}

    # Collect surface_id results, merge with cache
    sid_results = {}
    if cache is not None:
        for pid in cached_pids:
            sid_results[pid] = cache[pid]["surface_id"]
    for pid in new_pids:
        sid_results[pid] = sid_futures[pid].result()

    # Update cache with new entries
    if cache is not None:
        for pid in new_pids:
            cache[pid] = {"cwd": cwd_results.get(pid), "surface_id": sid_results.get(pid)}

    # Resolve branches (deduped)
    branch_results = {cwd: f.result() for cwd, f in branch_futures.items()}

    sessions = []
    for pid in valid_pids:
        info = proc_info[pid]
        cwd = cwd_results.get(pid)
        project = os.path.basename(cwd) if cwd else "unknown"
        surface_id = sid_results.get(pid)
        status = classify_status(info["cpu"], info["state"], cpu_threshold=cpu_threshold)
        uptime_seconds, uptime = uptime_futures[pid].result()
        branch = branch_results.get(cwd)
        registration = registrations.get(pid, {})
        sessions.append(
            {
                "pid": pid,
                "project": project,
                "cwd": cwd,
                "branch": branch,
                "status": status,
                "cpu": info["cpu"],
                "tty": info["tty"],
                "surface_id": surface_id,
                "uptime_seconds": uptime_seconds,
                "uptime": uptime,
                "task": registration.get("task"),
                "registered_at": registration.get("started_at"),
            }
        )

    disambiguate_projects(sessions)

    # Sort: active first, then idle, then stopped; alphabetical within each group
    status_order = {"active": 0, "idle": 1, "stopped": 2}
    sessions.sort(key=lambda s: (status_order.get(s["status"], 9), s["project"]))

    return sessions


def supports_color():
    """Check if terminal supports color output."""
    if os.environ.get("NO_COLOR"):
        return False
    return hasattr(sys.stdout, "isatty") and sys.stdout.isatty()


STATUS_DISPLAY = {
    "active": {"icon": "\u25cf", "label": "active", "color": "\033[32m"},
    "idle": {"icon": "\u25d0", "label": "idle", "color": "\033[33m"},
    "stopped": {"icon": "\u25a0", "label": "stopped", "color": "\033[90m"},
}
RESET = "\033[0m"


YELLOW = "\033[33m"


def truncate_value(value, width):
    """Truncate a string to width, adding ellipsis if needed."""
    if width <= 0:
        return ""
    if value is None:
        return "-"
    text = str(value)
    if len(text) <= width:
        return text
    if width == 1:
        return "\u2026"
    return f"{text[: width - 1]}\u2026"


def format_table(sessions, transitioned_pids=None, show_task=True, task_width=24):
    """Format sessions as an aligned table with optional ANSI colors."""
    if not sessions:
        return "  No active Claude/Codex sessions found.\n"

    use_color = supports_color()
    transitioned_pids = transitioned_pids or set()
    lines = []

    # Calculate column widths
    max_project = max(len(s["project"]) for s in sessions)
    max_branch = max(len(s.get("branch") or "-") for s in sessions)
    max_label = max(len(STATUS_DISPLAY[s["status"]]["label"]) for s in sessions)
    max_uptime = max(len(s.get("uptime", "-")) for s in sessions)
    max_task = 0
    if show_task:
        max_task = min(
            task_width,
            max(len(truncate_value(s.get("task"), task_width)) for s in sessions),
        )

    for s in sessions:
        disp = STATUS_DISPLAY[s["status"]]
        icon = disp["icon"]
        label = disp["label"]
        branch = s.get("branch") or "-"
        uptime = s.get("uptime", "-")
        identifier = s["surface_id"][:8] if s["surface_id"] else s["tty"]
        task = truncate_value(s.get("task"), task_width) if show_task else ""

        if use_color:
            icon_str = f'{disp["color"]}{icon}{RESET}'
        else:
            icon_str = icon

        line = f"  {icon_str} {s['project']:<{max_project}}  {branch:<{max_branch}}  {label:<{max_label}}  {uptime:<{max_uptime}}"
        if show_task:
            line += f"  {task:<{max_task}}"
        line += f"  {identifier}"

        if s.get("pid") in transitioned_pids:
            if use_color:
                line += f"  {YELLOW}<- done{RESET}"
            else:
                line += "  <- done"

        lines.append(line)

    # Summary
    total = len(sessions)
    counts = {}
    for s in sessions:
        counts[s["status"]] = counts.get(s["status"], 0) + 1

    parts = []
    for status in ("active", "idle", "stopped"):
        if status in counts:
            parts.append(f"{counts[status]} {status}")

    lines.append("")
    noun = "session" if total == 1 else "sessions"
    lines.append(f"  {total} {noun} ({', '.join(parts)})")

    return "\n".join(lines) + "\n"


def format_json(sessions):
    """Format sessions as JSON."""
    return json.dumps(sessions, indent=2) + "\n"


def current_utc_iso8601():
    """Return current UTC time in RFC3339-like format."""
    return datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")


def format_json_v2(sessions, generated_at=None):
    """Format sessions as versioned JSON envelope with metadata."""
    payload = {
        "schema_version": JSON_V2_SCHEMA_VERSION,
        "generated_at": generated_at or current_utc_iso8601(),
        "sessions": sessions,
    }
    return json.dumps(payload, indent=2) + "\n"


def resolve_watch_interval(args, sessions):
    """Resolve watch-mode sleep interval, optionally adapting by activity."""
    has_active = any(s["status"] == "active" for s in sessions)
    if has_active:
        return args.interval_active if args.interval_active is not None else args.interval
    return args.interval_idle if args.interval_idle is not None else args.interval


def print_snapshot(
    json_output=False,
    cache=None,
    cpu_threshold=DEFAULT_CPU_THRESHOLD,
    show_task=True,
    task_width=24,
):
    """Collect and print one snapshot."""
    sessions = collect_sessions(cache=cache, cpu_threshold=cpu_threshold)
    if json_output:
        sys.stdout.write(format_json(sessions))
    else:
        sys.stdout.write(format_table(sessions, show_task=show_task, task_width=task_width))


def clear_screen():
    sys.stdout.write("\033[2J\033[H")
    sys.stdout.flush()


def focus_ghostty_surface(surface_id):
    """Focus a Ghostty surface via its URL scheme. Returns True on success."""
    try:
        result = subprocess.run(
            ["open", f"ghostty://present-surface/{surface_id}"],
            capture_output=True,
            text=True,
        )
        return result.returncode == 0
    except FileNotFoundError:
        return False


def find_project_matches(sessions, project_query):
    """Find project matches using exact, then prefix, then substring."""
    query = project_query.strip().lower()
    if not query:
        return (None, [])

    exact = [s for s in sessions if s["project"].lower() == query]
    if exact:
        return ("exact", exact)

    prefix = [s for s in sessions if s["project"].lower().startswith(query)]
    if prefix:
        return ("prefix", prefix)

    substring = [s for s in sessions if query in s["project"].lower()]
    if substring:
        return ("substring", substring)

    return (None, [])


def handle_goto(project_query, cpu_threshold=DEFAULT_CPU_THRESHOLD):
    """Find a session by project name and focus its Ghostty surface."""
    sessions = collect_sessions(cpu_threshold=cpu_threshold)
    match_mode, matches = find_project_matches(sessions, project_query)

    if not matches:
        sys.stderr.write(f"  No session matching '{project_query}'.\n")
        if sessions:
            sys.stderr.write("  Available sessions:\n")
            for s in sessions:
                sys.stderr.write(f"    - {s['project']}\n")
        return 1

    if len(matches) > 1:
        mode_display = match_mode if match_mode else "project"
        sys.stderr.write(
            f"  Multiple {mode_display} matches for '{project_query}':\n"
        )
        for s in matches:
            sys.stderr.write(f"    - {s['project']}\n")
        sys.stderr.write("  Be more specific.\n")
        return 1

    session = matches[0]
    if not session.get("surface_id"):
        sys.stderr.write(f"  Session '{session['project']}' has no Ghostty surface ID.\n")
        sys.stderr.write("  It may not be running inside Ghostty.\n")
        return 1

    if focus_ghostty_surface(session["surface_id"]):
        sys.stdout.write(f"  Focused: {session['project']}\n")
        return 0
    else:
        sys.stderr.write(f"  Failed to focus surface for '{session['project']}'.\n")
        return 1


def main():
    args = parse_args()
    cpu_threshold = resolve_cpu_threshold(args)
    json_output = args.json_output or args.json_v2
    show_task = not args.no_task
    task_width = args.task_width

    if args.goto:
        sys.exit(handle_goto(args.goto, cpu_threshold=cpu_threshold))

    if args.watch:
        cache = {}
        previous_statuses = {}
        last_alerts = {}
        alert_on = args.alert_on
        try:
            while True:
                if not json_output:
                    clear_screen()
                sessions = collect_sessions(cache=cache, cpu_threshold=cpu_threshold)

                transitioned_pids = set()
                if args.alert and previous_statuses:
                    transitions = detect_transitions(previous_statuses, sessions, alert_on)
                    transitioned_pids = {
                        t["pid"]
                        for t in transitions
                        if t["from"] == "active" and t["to"] == "idle"
                    }
                    alert_transitions(
                        sessions,
                        transitions,
                        cooldown_seconds=args.alert_cooldown,
                        last_alerts=last_alerts,
                    )

                previous_statuses = {s["pid"]: s["status"] for s in sessions}

                if args.json_v2:
                    sys.stdout.write(format_json_v2(sessions))
                elif args.json_output:
                    sys.stdout.write(format_json(sessions))
                else:
                    sys.stdout.write(
                        format_table(
                            sessions,
                            transitioned_pids=transitioned_pids,
                            show_task=show_task,
                            task_width=task_width,
                        )
                    )
                time.sleep(resolve_watch_interval(args, sessions))
        except KeyboardInterrupt:
            pass
    else:
        if args.json_v2:
            sessions = collect_sessions(cpu_threshold=cpu_threshold)
            sys.stdout.write(format_json_v2(sessions))
        else:
            print_snapshot(
                json_output=args.json_output,
                cpu_threshold=cpu_threshold,
                show_task=show_task,
                task_width=task_width,
            )


if __name__ == "__main__":
    main()
